
#
#!/usr/bin/env Rscript

# Phase 04 - Step 04: Nestedness (NODF) Analysis
# -----------------------------------------------
# Purpose:
#   Calculate nestedness metrics for both FG-level and STR-level bipartite pyoverdine
#   interaction networks using the NODF (Nestedness metric based on Overlap and
#   Decreasing Fill) algorithm. Cross-validate results using multiple implementations.
#
# Scientific Context:
#   Nestedness is a key property of ecological interaction networks where specialized
#   species tend to interact with subsets of the species that generalists interact with.
#   In siderophore networks, high nestedness suggests hierarchical organization of
#   resource sharing, while low nestedness indicates more specialized or modular
#   interaction patterns.
#
#   The NODF metric ranges from 0 (no nestedness) to 100 (perfectly nested).
#   It is computed based on:
#   1. Decreasing fill: rows and columns should be ordered by decreasing degree
#   2. Overlap: paired overlap between rows and columns
#
# Methodological Specifications:
#   - Primary implementation: bipartite::nestednodf()
#   - Cross-validation: vegan::nestednodf() for consistency check
#   - Matrix orientation: standardized incidence matrix (nodes vs pyov)
#   - Statistical context: values comparable to Gu et al. (2025) siderophore networks
#
# Responsibilities:
#   1. Load validated adjacency matrices and preflight status
#   2. Construct standardized bipartite incidence matrices
#   3. Compute NODF using bipartite package (primary method)
#   4. Cross-validate with vegan package implementation
#   5. Generate nestedness visualizations:
#      - Matrix heatmaps with optimal ordering
#      - NODF component breakdown (row/column contributions)
#   6. Save comprehensive results and documentation
#
# Outputs:
#   - results/phase_04/nestedness/nestedness_fg.rds
#   - results/phase_04/nestedness/nestedness_str.rds
#   - figures/network_topology/nodf_matrix_fg.pdf
#   - figures/network_topology/nodf_matrix_str.pdf
#   - figures/network_topology/nodf_comparison.pdf
#   - docs/phase_04/logs/step04_nestedness_summary.txt
#
# Usage:
#   Rscript scripts/phase_04_topology/04_nestedness_nodf.R
#
# Dependencies:
#   - Matrix, ggplot2, dplyr, bipartite, vegan, pheatmap
#
# Author: automated assistant
# Date: autogenerated

suppressPackageStartupMessages({
  library(Matrix)
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  library(bipartite)
  library(vegan)
  library(pheatmap)
  library(readr)
})

# -----------------------------
# Helper functions
# -----------------------------
safe_dir_create <- function(path) {
  if (!dir.exists(path)) dir.create(path, recursive = TRUE, showWarnings = FALSE)
}

timestamp <- function() format(Sys.time(), "%Y-%m-%d %H:%M:%S %Z")

# Construct standardized incidence matrix for nestedness analysis
# Returns: binary matrix where rows = agents (FG/STR), cols = pyov communities
build_incidence_matrix <- function(adj_production, adj_utilization) {
  # For nestedness, we need a binary interaction matrix
  # An interaction exists if either production OR utilization occurs
  # This represents the overall bipartite interaction pattern

  # adj_production: agents x pyov (agents produce pyovs)
  # adj_utilization: pyov x agents (pyovs consumed by agents)

  # Convert utilization matrix to same orientation as production
  adj_util_reoriented <- t(adj_utilization)  # agents x pyov

  # Create incidence matrix: interaction = production OR utilization
  incidence_matrix <- adj_production | adj_util_reoriented

  # Ensure binary
  incidence_matrix <- as.matrix(incidence_matrix > 0) * 1

  # Order by decreasing degree for NODF calculation
  row_sums <- rowSums(incidence_matrix)
  col_sums <- colSums(incidence_matrix)

  # Order rows and columns by decreasing degree (ties broken by name)
  row_order <- order(row_sums, decreasing = TRUE, rownames(incidence_matrix))
  col_order <- order(col_sums, decreasing = TRUE, colnames(incidence_matrix))

  incidence_matrix <- incidence_matrix[row_order, col_order, drop = FALSE]

  attr(incidence_matrix, "row_order") <- row_order
  attr(incidence_matrix, "col_order") <- col_order

  return(incidence_matrix)
}

# Create nestedness matrix heatmap
plot_nestedness_matrix <- function(incidence_matrix, title, nodf_value = NULL) {
  df <- as.data.frame(as.table(incidence_matrix))
  colnames(df) <- c("Agent", "Pyov", "Interaction")

  p <- ggplot(df, aes(x = Pyov, y = Agent, fill = as.factor(Interaction))) +
    geom_tile(color = "white", linewidth = 0.5) +
    scale_fill_manual(values = c("white", "black"), name = "Interaction") +
    labs(title = title, x = "Pyoverdine Communities", y = "Agents") +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 12),
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 6),
      axis.text.y = element_text(size = 6),
      legend.position = "bottom"
    )

  # Add NODF value to title if provided
  if (!is.null(nodf_value)) {
    p <- p + labs(title = paste(title, sprintf("(NODF = %.2f)", nodf_value)))
  }

  return(p)
}

# Comprehensive NODF analysis using bipartite package
compute_nodf_bipartite <- function(incidence_matrix) {
  # Robust nestedness computation using bipartite::nested() for NODF where available,
  # with a fallback to vegan::nestednodf(). This function defensively extracts
  # a scalar NODF total and optional row/column components if present.
  nodf_total <- NA_real_
  nodf_rows <- NA
  nodf_cols <- NA

  # Try primary method: bipartite::nested with NODF request (different bipartite
  # versions expose outputs differently). Use tryCatch to avoid hard failures.
  res_primary <- tryCatch({
    bipartite::nested(incidence_matrix, method = "NODF")
  }, error = function(e) {
    NULL
  }, warning = function(w) {
    # still capture the result if it returned something
    NULL
  })

  if (!is.null(res_primary)) {
    # If the result is a single numeric, treat as total NODF
    if (is.numeric(res_primary) && length(res_primary) == 1) {
      nodf_total <- as.numeric(res_primary)
    } else if (is.list(res_primary)) {
      # Common possible field names - check defensively
      possible_fields <- c("statistic", "NODF", "value", "nestedness", "NODF_total")
      for (nm in possible_fields) {
        if (!is.null(res_primary[[nm]]) && is.numeric(res_primary[[nm]]) && length(res_primary[[nm]]) == 1) {
          nodf_total <- as.numeric(res_primary[[nm]])
          break
        }
      }
      # Try to extract row/column components if present
      if (!is.null(res_primary$NODF_rows)) nodf_rows <- res_primary$NODF_rows
      if (!is.null(res_primary$NODF_cols)) nodf_cols <- res_primary$NODF_cols
      if (!is.null(res_primary$rows)) {
        # some implementations might name these lists differently
        nodf_rows <- res_primary$rows
      }
      if (!is.null(res_primary$cols)) {
        nodf_cols <- res_primary$cols
      }
    }
  }

  # Fallback: vegan::nestednodf returns a numeric total; use if primary failed
  if (is.na(nodf_total)) {
    res_vegan <- tryCatch({
      vegan::nestednodf(incidence_matrix)
    }, error = function(e) {
      NA_real_
    })
    if (is.numeric(res_vegan) && length(res_vegan) == 1 && !is.na(res_vegan)) {
      nodf_total <- as.numeric(res_vegan)
    }
  }

  # System properties
  n_rows <- nrow(incidence_matrix)
  n_cols <- ncol(incidence_matrix)
  total_interactions <- sum(incidence_matrix)
  matrix_fill <- total_interactions / (n_rows * n_cols)

  result <- list(
    nodf_total = nodf_total,
    nodf_rows = nodf_rows,
    nodf_cols = nodf_cols,
    n_rows = n_rows,
    n_cols = n_cols,
    total_interactions = total_interactions,
    matrix_fill = matrix_fill,
    method = "bipartite::nested (NODF) with vegan fallback",
    incidence_matrix = incidence_matrix,
    row_degrees = rowSums(incidence_matrix),
    col_degrees = colSums(incidence_matrix)
  )

  return(result)
}

# Cross-validation using vegan package
compute_nodf_vegan <- function(incidence_matrix) {
  # Cross-validation using vegan; sanitize output into a single scalar NODF
  tryCatch({
    raw <- vegan::nestednodf(incidence_matrix)
    nodf_total <- NA_real_
    # Cases:
    # 1) numeric scalar
    if (is.numeric(raw) && length(raw) == 1) {
      nodf_total <- as.numeric(raw)
    }
    # 2) list or S3 object with possible components
    if (is.list(raw) && (is.na(nodf_total) || length(nodf_total) != 1)) {
      # Try direct common names
      for (nm in c("NODF", "nodf", "value", "nestedness", "statistic")) {
        if (!is.null(raw[[nm]])) {
          candidate <- raw[[nm]]
          # If statistic itself is a list holding NODF
          if (is.list(candidate)) {
            for (sn in c("NODF", "nodf", "value", "nestedness")) {
              if (!is.null(candidate[[sn]]) && is.numeric(candidate[[sn]]) && length(candidate[[sn]]) >= 1) {
                nodf_total <- as.numeric(candidate[[sn]][1])
                break
              }
            }
          } else if (is.numeric(candidate) && length(candidate) >= 1) {
            nodf_total <- as.numeric(candidate[1])
          }
        }
        if (!is.na(nodf_total)) break
      }
    }
    # Final fallback: first numeric value found anywhere
    if (is.na(nodf_total)) {
      nums <- unlist(raw[vlapply(raw, is.numeric)], use.names = FALSE)
      if (length(nums) > 0) nodf_total <- as.numeric(nums[1])
    }
    result <- list(
      nodf_total = nodf_total,
      method = "vegan::nestednodf",
      convergence = ifelse(is.na(nodf_total), "partial", "success")
    )
    result
  }, error = function(e) {
    list(
      nodf_total = NA_real_,
      method = "vegan::nestednodf",
      convergence = "failed",
      error_message = e$message
    )
  })
}

# -----------------------------
# Directory setup
# -----------------------------
safe_dir_create("results/phase_04/nestedness")
safe_dir_create("figures/network_topology")
# Create a dedicated subfolder for Step 04 nestedness figures
safe_dir_create("figures/network_topology/step04_nestedness")
safe_dir_create("docs/phase_04/logs")
# Ensure a top-level docs folder exists for a human-readable summary
safe_dir_create("docs/phase_04")

# -----------------------------
# Load preflight validation and data
# -----------------------------
cat("Loading preflight validation and adjacency matrices for nestedness analysis...\n")

# Check preflight status
preflight_path <- "results/phase_04/preflight_status.rds"
if (!file.exists(preflight_path)) {
  stop("Preflight validation not found. Run Step 01 first.")
}

preflight <- readRDS(preflight_path)
if (preflight$critical_failures > 0) {
  stop("Critical failures detected in preflight. Resolve before proceeding.")
}

# Load adjacency matrices
adj_prod_fg <- readRDS("data/interim/adj_production_FG_agentsxpyov_conservative.rds")
adj_util_fg <- readRDS("data/interim/adj_utilization_FG_pyovxagents_conservative.rds")
adj_prod_str <- readRDS("data/interim/adj_production_STR_agentsxpyov_conservative.rds")
adj_util_str <- readRDS("data/interim/adj_utilization_STR_pyovxagents_conservative.rds")

# Load node tables for reference
fg_nodes <- readRDS("data/interim/nodes_functional_groups_conservative.rds")
str_nodes <- readRDS("data/interim/nodes_strains_conservative.rds")
pyov_nodes <- readRDS("data/interim/nodes_pyoverdines_conservative.rds")

cat("Data loaded successfully.\n")

# -----------------------------
# Build incidence matrices
# -----------------------------
cat("Constructing incidence matrices for nestedness analysis...\n")

# FG-level incidence matrix
incidence_fg <- build_incidence_matrix(adj_prod_fg, adj_util_fg)

# STR-level incidence matrix
incidence_str <- build_incidence_matrix(adj_prod_str, adj_util_str)

cat(sprintf("FG incidence matrix: %d x %d (%.1f%% fill)\n",
            nrow(incidence_fg), ncol(incidence_fg),
            100 * sum(incidence_fg) / (nrow(incidence_fg) * ncol(incidence_fg))))

cat(sprintf("STR incidence matrix: %d x %d (%.1f%% fill)\n",
            nrow(incidence_str), ncol(incidence_str),
            100 * sum(incidence_str) / (nrow(incidence_str) * ncol(incidence_str))))

# -----------------------------
# Compute NODF - FG level
# -----------------------------
cat("Computing NODF for FG-level network...\n")

# Primary calculation using bipartite package
nodf_fg_bipartite <- compute_nodf_bipartite(incidence_fg)

# Cross-validation with vegan package
nodf_fg_vegan <- compute_nodf_vegan(incidence_fg)

# Combine results
nodf_fg <- list(
  primary = nodf_fg_bipartite,
  cross_validation = nodf_fg_vegan,
  metadata = list(
    network_level = "functional_groups",
    n_agents = length(unique(fg_nodes$functional_group_id)),
    n_pyov = nrow(pyov_nodes),
    timestamp = timestamp()
  )
)

# -----------------------------
# Compute NODF - STR level
# -----------------------------
cat("Computing NODF for STR-level network...\n")

# Primary calculation using bipartite package
nodf_str_bipartite <- compute_nodf_bipartite(incidence_str)

# Cross-validation with vegan package
nodf_str_vegan <- compute_nodf_vegan(incidence_str)

# Combine results
nodf_str <- list(
  primary = nodf_str_bipartite,
  cross_validation = nodf_str_vegan,
  metadata = list(
    network_level = "strains",
    n_agents = nrow(str_nodes),
    n_pyov = nrow(pyov_nodes),
    timestamp = timestamp()
  )
)

# -----------------------------
# Save results
# -----------------------------
cat("Saving NODF results...\n")

saveRDS(nodf_fg, "results/phase_04/nestedness/nestedness_fg.rds")
saveRDS(nodf_str, "results/phase_04/nestedness/nestedness_str.rds")

# -----------------------------
# Generate visualizations
# -----------------------------
cat("Generating nestedness visualizations...\n")

# FG matrix heatmap
p_fg_matrix <- plot_nestedness_matrix(
  incidence_fg,
  "Functional Group Network - Nestedness Matrix",
  nodf_fg$primary$nodf_total
)
ggsave("figures/network_topology/step04_nestedness/nodf_matrix_fg.pdf", p_fg_matrix,
       width = 10, height = 8)

# STR matrix heatmap (subset if too large)
if (nrow(incidence_str) <= 200) {
  p_str_matrix <- plot_nestedness_matrix(
    incidence_str,
    "Strain Network - Nestedness Matrix",
    nodf_str$primary$nodf_total
  )
  ggsave("figures/network_topology/step04_nestedness/nodf_matrix_str.pdf", p_str_matrix,
         width = 10, height = 12)
} else {
  # For large networks, create a summary plot
  top_strains <- head(order(rowSums(incidence_str), decreasing = TRUE), 200)
  incidence_str_subset <- incidence_str[top_strains, ]

  p_str_matrix <- plot_nestedness_matrix(
    incidence_str_subset,
    "Strain Network - Nestedness Matrix (Top 200 Strains)",
    nodf_str$primary$nodf_total
  )
  ggsave("figures/network_topology/step04_nestedness/nodf_matrix_str.pdf", p_str_matrix,
         width = 10, height = 12)
}

# Comparison plot
comparison_data <- data.frame(
  Network = c("Functional Groups", "Strains"),
  NODF = c(nodf_fg$primary$nodf_total, nodf_str$primary$nodf_total),
  Rows = c(nodf_fg$primary$n_rows, nodf_str$primary$n_rows),
  Columns = c(nodf_fg$primary$n_cols, nodf_str$primary$n_cols),
  Fill_Percent = c(100 * nodf_fg$primary$matrix_fill, 100 * nodf_str$primary$matrix_fill)
)

p_comparison <- ggplot(comparison_data, aes(x = Network, y = NODF, fill = Network)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = sprintf("%.2f", NODF)), vjust = -0.5, size = 4) +
  labs(title = "Nestedness (NODF) Comparison",
       subtitle = "Functional Groups vs Strains",
       y = "NODF Score (0-100)", x = "Network Level") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))

ggsave("figures/network_topology/step04_nestedness/nodf_comparison.pdf", p_comparison,
       width = 8, height = 6)

# -----------------------------
# Generate summary report
# -----------------------------
cat("Generating summary report...\n")

# Build safe cross-validation lines for vegan results (avoid vector-length issues)
veg_fg_line <- if (!is.null(nodf_fg$cross_validation$nodf_total) &&
                   length(nodf_fg$cross_validation$nodf_total) == 1 &&
                   !is.na(nodf_fg$cross_validation$nodf_total)) {
  sprintf("  NODF (vegan): %.2f [cross-validation]", nodf_fg$cross_validation$nodf_total)
} else if (!is.null(nodf_fg$cross_validation$error_message)) {
  sprintf("  NODF (vegan): %s [cross-validation failed]", nodf_fg$cross_validation$error_message)
} else {
  "  NODF (vegan): NA [cross-validation unavailable]"
}

veg_str_line <- if (!is.null(nodf_str$cross_validation$nodf_total) &&
                    length(nodf_str$cross_validation$nodf_total) == 1 &&
                    !is.na(nodf_str$cross_validation$nodf_total)) {
  sprintf("  NODF (vegan): %.2f [cross-validation]", nodf_str$cross_validation$nodf_total)
} else if (!is.null(nodf_str$cross_validation$error_message)) {
  sprintf("  NODF (vegan): %s [cross-validation failed]", nodf_str$cross_validation$error_message)
} else {
  "  NODF (vegan): NA [cross-validation unavailable]"
}

summary_lines <- c(
  "Phase 04 - Step 04: Nestedness (NODF) Analysis Summary",
  paste("Timestamp:", timestamp()),
  "",
  "Functional Group (FG) Level:",
  sprintf("  Network size: %d FGs × %d Pyovs",
          nodf_fg$primary$n_rows, nodf_fg$primary$n_cols),
  sprintf("  Total interactions: %d (%.1f%% matrix fill)",
          nodf_fg$primary$total_interactions, 100 * nodf_fg$primary$matrix_fill),
  sprintf("  NODF (bipartite): %.2f", as.numeric(nodf_fg$primary$nodf_total[1])),
  sprintf("    - Row nestedness: %.2f", ifelse(is.null(nodf_fg$primary$nodf_rows), NA, nodf_fg$primary$nodf_rows)),
  sprintf("    - Column nestedness: %.2f", ifelse(is.null(nodf_fg$primary$nodf_cols), NA, nodf_fg$primary$nodf_cols)),
  veg_fg_line,
  "",
  "Strain (STR) Level:",
  sprintf("  Network size: %d Strains × %d Pyovs",
          nodf_str$primary$n_rows, nodf_str$primary$n_cols),
  sprintf("  Total interactions: %d (%.1f%% matrix fill)",
          nodf_str$primary$total_interactions, 100 * nodf_str$primary$matrix_fill),
  sprintf("  NODF (bipartite): %.2f", as.numeric(nodf_str$primary$nodf_total[1])),
  sprintf("    - Row nestedness: %.2f", ifelse(is.null(nodf_str$primary$nodf_rows), NA, nodf_str$primary$nodf_rows)),
  sprintf("    - Column nestedness: %.2f", ifelse(is.null(nodf_str$primary$nodf_cols), NA, nodf_str$primary$nodf_cols)),
  veg_str_line,
  "",
  "Interpretation Guidelines:",
  "  NODF < 10: Low nestedness (strongly modular structure)",
  "  NODF 10-30: Moderate nestedness (mixed modular-nested structure)",
  "  NODF > 30: High nestedness (hierarchical resource sharing)",
  "",
  "Outputs saved:",
  "  - results/phase_04/nestedness/nestedness_fg.rds",
  "  - results/phase_04/nestedness/nestedness_str.rds",
  "  - figures/network_topology/nodf_matrix_fg.pdf",
  "  - figures/network_topology/nodf_matrix_str.pdf",
  "  - figures/network_topology/nodf_comparison.pdf",
  "",
  "Ready for Step 05: Shannon Entropy Calculation."
)

summary_lines <- summary_lines

writeLines(summary_lines, "docs/phase_04/logs/step04_nestedness_summary.txt")
# Also write a human-readable summary at the docs/phase_04 top-level for quick access
writeLines(summary_lines, "docs/phase_04/step04_nestedness_summary.txt")
cat(paste(summary_lines, collapse = "\n"), "\n")

# Save session info
writeLines(capture.output(sessionInfo()), "docs/phase_04/logs/step04_session_info.txt")

cat("Step 04 complete. Nestedness (NODF) analysis finished.\n")
