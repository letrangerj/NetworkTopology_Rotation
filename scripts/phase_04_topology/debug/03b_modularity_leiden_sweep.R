#!/usr/bin/env Rscript

# Debug script: Step 03b - Leiden resolution sweep (debug)
# -------------------------------------------------------
# Purpose:
#  - Run Leiden community detection across a range of resolution parameters.
#  - For each resolution, run multiple replicates to assess stability.
#  - Compute per-resolution diagnostics: modularity distribution, pairwise ARI,
#    co-assignment matrix, node/module stability summaries, and diagnostic plots.
#  - Save results under results/phase_04/modularity/leiden_sweep/<res_label>/ and
#    figures under figures/network_topology/step03_modularity_figures/leiden_sweep/<res_label>/
#
# Usage:
#  Rscript scripts/phase_04_topology/debug/03b_modularity_leiden_sweep.R
#
# Notes:
#  - This is an exploratory debug script. It is intentionally verbose and saves
#    intermediate artifacts for inspection.
#  - Defaults are conservative; you can override via environment variables:
#      LEIDEN_REPLICATES  -> integer, replicates per resolution (default 50)
#      LEIDEN_RESOLUTIONS -> comma-separated list of numeric resolutions (default "0.5,1.0,1.5,2.0")
#      LEIDEN_MASTER_SEED -> integer seed base (default from manifest if present else 2025)
#
# Requirements:
#  - R packages: igraph (with cluster_leiden), dplyr, readr, ggplot2, tidyr, pheatmap, mclust
#  - Input: data/interim/edges_functional_groups_conservative.csv
#
# Author: automated assistant (debug)
# Date: autogenerated

suppressPackageStartupMessages({
  library(igraph)
  library(dplyr)
  library(readr)
  library(ggplot2)
  library(tidyr)
  library(pheatmap)
  library(mclust)   # for adjustedRandIndex
})

# -----------------------------
# Parameters (configurable)
# -----------------------------
# Read manifest for defaults if available
manifest_path <- "docs/phase_04/parameters_manifest.json"
manifest <- if (file.exists(manifest_path)) tryCatch(jsonlite::fromJSON(manifest_path), error = function(e) list()) else list()

default_reps <- as.integer(Sys.getenv("LEIDEN_REPLICATES", unset = if (!is.null(manifest$modularity_replicates$pilot)) manifest$modularity_replicates$pilot else 50))
resolutions_env <- Sys.getenv("LEIDEN_RESOLUTIONS", unset = "0.5,1.0,1.5,2.0")
resolutions <- as.numeric(strsplit(resolutions_env, ",", fixed = TRUE)[[1]])
master_seed <- as.integer(Sys.getenv("LEIDEN_MASTER_SEED", unset = if (!is.null(manifest$master_seed)) manifest$master_seed else 2025L))
n_reps <- default_reps

# Output base directories
out_base <- "results/phase_04/modularity/leiden_sweep"
fig_base <- "figures/network_topology/step03_modularity_figures/leiden_sweep"

dir.create(out_base, recursive = TRUE, showWarnings = FALSE)
dir.create(fig_base, recursive = TRUE, showWarnings = FALSE)

# Input edges (use the Phase 3 edge list)
edges_csv <- "data/interim/edges_functional_groups_conservative.csv"
if (!file.exists(edges_csv)) {
  stop("Required edges CSV not found: ", edges_csv, "\nRun Phase 03 adjacency building first.")
}

# -----------------------------
# Build undirected bipartite graph (consistent with earlier scripts)
# -----------------------------
edges_df <- read_csv(edges_csv, show_col_types = FALSE)

# Keep only edges between functional_group and pyoverdine
edges_sub <- edges_df %>%
  filter((source_type == "functional_group" & target_type == "pyoverdine") |
           (source_type == "pyoverdine" & target_type == "functional_group")) %>%
  transmute(a = source, b = target) %>%
  rowwise() %>%
  mutate(n1 = min(c(a, b)), n2 = max(c(a, b))) %>%
  ungroup() %>%
  transmute(from = n1, to = n2) %>%
  distinct()

# vertex set: include all FG and PYO nodes to preserve isolated nodes
fg_nodes <- readRDS("data/interim/nodes_functional_groups_conservative.rds")
pyov_nodes <- readRDS("data/interim/nodes_pyoverdines_conservative.rds")
vertex_ids <- unique(c(edges_sub$from, edges_sub$to, fg_nodes$agent_id, pyov_nodes$node_id))

g <- graph_from_data_frame(edges_sub, directed = FALSE, vertices = data.frame(name = vertex_ids, stringsAsFactors = FALSE))
g <- simplify(g, remove.multiple = TRUE, remove.loops = TRUE)
V(g)$type <- ifelse(V(g)$name %in% fg_nodes$agent_id, "fg",
                    ifelse(V(g)$name %in% pyov_nodes$node_id, "pyov", "unknown"))

message(sprintf("Graph: %d vertices (%d FG, %d PYO), %d edges", vcount(g),
                sum(V(g)$type == "fg"), sum(V(g)$type == "pyov"), ecount(g)))

# -----------------------------
# Helpers
# -----------------------------
safe_dir <- function(path) {
  if (!dir.exists(path)) dir.create(path, recursive = TRUE, showWarnings = FALSE)
  path
}

timestamp_label <- function() gsub("[:\\s]", "-", format(Sys.time(), "%Y-%m-%d_%H-%M-%S"))

# For reproducible seed per resolution & replicate
seed_for <- function(res_index, r) {
  # Derive a reproducible seed given master_seed, res_index, replicate r
  # Keep within integer limits
  as.integer((master_seed + as.integer(round(resolutions[res_index] * 100)) * 10000L + r) %% .Machine$integer.max)
}

# Compute co-assignment matrix from membership matrix (nodes x replicates)
compute_coassign <- function(membership_mat) {
  # membership_mat: matrix with rows = nodes (names as rownames), cols = replicates
  nodes <- rownames(membership_mat)
  n <- length(nodes)
  co <- matrix(0, nrow = n, ncol = n, dimnames = list(nodes, nodes))
  for (i in seq_len(n)) {
    for (j in i:n) {
      eq <- sum(membership_mat[i, ] == membership_mat[j, ])
      prop <- eq / ncol(membership_mat)
      co[i, j] <- prop
      co[j, i] <- prop
    }
  }
  co
}

# -----------------------------
# Sweep resolutions
# -----------------------------
summary_rows <- list()

for (ri in seq_along(resolutions)) {
  res_val <- resolutions[ri]
  res_label <- paste0("res", gsub("\\.", "_", as.character(res_val)))
  out_dir <- file.path(out_base, res_label)
  fig_dir <- file.path(fig_base, res_label)
  safe_dir(out_dir)
  safe_dir(fig_dir)

  message("Running resolution: ", res_val, " (label=", res_label, "), replicates=", n_reps)
  # storage
  node_names <- V(g)$name
  n_nodes <- length(node_names)
  memberships <- matrix(NA_integer_, nrow = n_nodes, ncol = n_reps, dimnames = list(node_names, paste0("rep_", seq_len(n_reps))))
  modularity_vals <- numeric(n_reps)

  # Run replicates
  for (r in seq_len(n_reps)) {
    seed_r <- seed_for(ri, r)
    set.seed(seed_r)
    # Use cluster_leiden if available. fall back to cluster_louvain if error.
    cl <- tryCatch({
      cluster_leiden(g, resolution_parameter = res_val)
    }, error = function(e) {
      message("cluster_leiden failed; falling back to cluster_louvain for replicate ", r, ". Error: ", e$message)
      # cluster_louvain doesn't accept resolution_parameter directly in igraph; we use as fallback (no resolution control)
      cluster_louvain(g)
    })
    mem <- membership(cl)
    # membership order matches V(g)$name
    # If permuted or differently ordered, align by names
    if (is.null(names(mem))) {
      # assume order corresponds to V(g)
      memberships[, r] <- as.integer(mem)
    } else {
      # align
      memberships[names(mem), r] <- as.integer(mem)
    }
    modularity_vals[r] <- tryCatch(modularity(cl), error = function(e) NA_real_)
    if (r %% 10 == 0) message("  completed replicate ", r)
  }

  # Save raw membership matrix and modularity vector
  saveRDS(memberships, file = file.path(out_dir, "memberships_matrix.rds"))
  write.csv(as.data.frame(memberships, stringsAsFactors = FALSE) %>% tibble::rownames_to_column("node_id"),
            file = file.path(out_dir, "memberships_matrix.csv"), row.names = FALSE)
  write.csv(data.frame(replicate = seq_len(n_reps), modularity = modularity_vals),
            file = file.path(out_dir, "modularity_values.csv"), row.names = FALSE)

  # Compute pairwise ARI across replicates
  if (n_reps >= 2) {
    rep_pairs <- combn(n_reps, 2)
    ari_vals <- apply(rep_pairs, 2, function(idx) {
      a <- memberships[, idx[1]]
      b <- memberships[, idx[2]]
      mclust::adjustedRandIndex(a, b)
    })
    ari_df <- data.frame(pair = apply(rep_pairs, 2, function(x) paste0("rep", x[1], "_rep", x[2])), ARI = ari_vals, stringsAsFactors = FALSE)
    write.csv(ari_df, file = file.path(out_dir, "pairwise_ARI.csv"), row.names = FALSE)
    # Plot ARI histogram
    p_ari <- ggplot(ari_df, aes(x = ARI)) +
      geom_histogram(bins = 30, fill = "steelblue", color = "white") +
      labs(title = paste0("Pairwise ARI (Leiden) res=", res_val), x = "ARI", y = "Count") +
      theme_minimal()
    ggsave(filename = file.path(fig_dir, "pairwise_ARI_hist.pdf"), plot = p_ari, width = 6, height = 4)
  } else {
    ari_df <- data.frame()
  }

  # Compute co-assignment matrix
  coassign <- compute_coassign(memberships)
  saveRDS(coassign, file = file.path(out_dir, "coassignment_matrix.rds"))
  write.csv(coassign, file = file.path(out_dir, "coassignment_matrix.csv"), row.names = TRUE)

  # Compute module stability (use consensus by clustering coassign)
  # Derive a consensus partition by running Leiden on the coassignment matrix treated as weighted graph
  g_co <- graph_from_adjacency_matrix(coassign, mode = "undirected", weighted = TRUE, diag = FALSE)
  cons_cl <- tryCatch(cluster_leiden(g_co), error = function(e) cluster_louvain(g_co))
  cons_mem <- membership(cons_cl)
  # Save consensus membership
  write.csv(data.frame(node_id = names(cons_mem), consensus_module = as.integer(cons_mem), stringsAsFactors = FALSE),
            file = file.path(out_dir, "consensus_membership.csv"), row.names = FALSE)

  # Compute node-level mean within-module co-assignment
  modules <- split(names(cons_mem), cons_mem)
  node_stats <- data.frame(node_id = character(0), consensus_module = integer(0),
                           mean_within = numeric(0), median_within = numeric(0), sd_within = numeric(0),
                           stringsAsFactors = FALSE)
  for (m in names(modules)) {
    members <- modules[[m]]
    if (length(members) <= 1) {
      node_stats <- rbind(node_stats, data.frame(node_id = members, consensus_module = as.integer(m),
                                                 mean_within = NA_real_, median_within = NA_real_, sd_within = NA_real_,
                                                 stringsAsFactors = FALSE))
    } else {
      subm <- coassign[members, members, drop = FALSE]
      for (v in members) {
        vals <- as.numeric(subm[v, setdiff(members, v)])
        node_stats <- rbind(node_stats, data.frame(node_id = v, consensus_module = as.integer(m),
                                                   mean_within = mean(vals, na.rm = TRUE),
                                                   median_within = median(vals, na.rm = TRUE),
                                                   sd_within = sd(vals, na.rm = TRUE),
                                                   stringsAsFactors = FALSE))
      }
    }
  }
  write.csv(node_stats, file = file.path(out_dir, "node_stability.csv"), row.names = FALSE)

  module_stats <- node_stats %>%
    group_by(consensus_module) %>%
    summarize(module_mean_within = mean(mean_within, na.rm = TRUE),
              module_median_within = median(mean_within, na.rm = TRUE),
              n_members = n()) %>%
    arrange(desc(module_mean_within))
  write.csv(module_stats, file = file.path(out_dir, "module_stability.csv"), row.names = FALSE)

  # Visualize co-assignment heatmap for this resolution (ordered by consensus membership)
  order_nodes <- names(sort(cons_mem))
  coassign_ord <- coassign[order_nodes, order_nodes, drop = FALSE]
  annot <- data.frame(module = factor(cons_mem[order_nodes]))
  rownames(annot) <- order_nodes
  pheatmap::pheatmap(coassign_ord,
                     cluster_rows = FALSE, cluster_cols = FALSE,
                     show_rownames = FALSE, show_colnames = FALSE,
                     annotation_row = annot, annotation_col = annot,
                     filename = file.path(fig_dir, "coassignment_heatmap.pdf"),
                     main = paste0("Co-assignment (res=", res_val, ")"),
                     silent = TRUE)

  # Plot modularity histogram
  df_mod <- data.frame(modularity = modularity_vals)
  p_mod <- ggplot(df_mod, aes(x = modularity)) +
    geom_histogram(bins = max(10, round(n_reps / 5)), fill = "lightgreen", color = "white") +
    labs(title = paste0("Modularity (Leiden) res=", res_val), x = "Modularity Q", y = "Count") +
    theme_minimal()
  ggsave(filename = file.path(fig_dir, "modularity_hist.pdf"), plot = p_mod, width = 6, height = 4)

  # Summarize this resolution
  summary_rows[[res_label]] <- data.frame(resolution = res_val,
                                          mean_modularity = mean(modularity_vals, na.rm = TRUE),
                                          sd_modularity = sd(modularity_vals, na.rm = TRUE),
                                          mean_pairwise_ARI = ifelse(length(ari_df) > 0, mean(ari_df$ARI, na.rm = TRUE), NA_real_),
                                          median_pairwise_ARI = ifelse(length(ari_df) > 0, median(ari_df$ARI, na.rm = TRUE), NA_real_),
                                          n_replicates = n_reps,
                                          n_nodes = n_nodes,
                                          n_edges = ecount(g),
                                          stringsAsFactors = FALSE)
  # Save per-resolution summary
  write.csv(summary_rows[[res_label]], file = file.path(out_dir, "resolution_summary.csv"), row.names = FALSE)

  message("Completed resolution ", res_val, " -> outputs in ", out_dir, " and figures in ", fig_dir)
}

# Aggregate resolution-wide summary
summary_df <- bind_rows(summary_rows)
write.csv(summary_df, file = file.path(out_base, "leiden_sweep_summary.csv"), row.names = FALSE)
message("Leiden sweep complete. Summary saved to: ", file.path(out_base, "leiden_sweep_summary.csv"))
message("Figures saved under: ", fig_base)

# End of script
