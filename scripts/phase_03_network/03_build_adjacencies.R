#!/usr/bin/env Rscript

# Step 3: Build adjacency matrices and edge lists for FG and STR networks
# - Production adjacency: Agents (rows) x Pyoverdines (cols)  => entry [i,j] = 1 means agent_i produces pyov_j (agent -> pyov)
# - Utilization adjacency: Pyoverdines (rows) x Agents (cols) => entry [r,c] = 1 means pyov_r -> agent_c (pyov -> agent)
#
# Outputs:
#  - data/interim/adj_production_FG_agentsxpyov_conservative.rds
#  - data/interim/adj_utilization_FG_pyovxagents_conservative.rds
#  - data/interim/edges_functional_groups_conservative.rds / .csv
#  - data/interim/adj_production_STR_agentsxpyov_conservative.rds
#  - data/interim/adj_utilization_STR_pyovxagents_conservative.rds
#  - data/interim/edges_strains_conservative.rds / .csv
#  - data/interim/degree_sequences_conservative.rds
#  - docs/phase_03/phase_03_network_summary.txt
#  - docs/phase_03/session_info_adj_build.txt
#
# Usage:
#   Rscript scripts/phase_03_network/03_build_adjacencies.R
#
# Notes:
#  - The script expects Step 1 and Step 2 outputs to exist:
#      data/interim/nodes_functional_groups_conservative.rds
#      data/interim/nodes_strains_conservative.rds
#      data/interim/nodes_pyoverdines_conservative.rds
#
#  - Adjacencies are binary. No edge weights are added here.
#  - All objects are saved as RDS. Edge lists are saved as CSV for readability.
#
# Author: automated assistant (generated)
# Date: autogenerated

suppressPackageStartupMessages({
  library(dplyr)
  library(purrr)
  library(readr)
  library(Matrix)
  library(igraph)
})

# Helper: fail cleanly if required files missing
require_file <- function(path) {
  if (!file.exists(path)) {
    stop("Required file missing: ", path, "\nPlease run previous steps to generate it.")
  }
  path
}

# Input node files (produced in Step 1 & Step 2)
fg_nodes_path    <- "data/interim/nodes_functional_groups_conservative.rds"
strain_nodes_path<- "data/interim/nodes_strains_conservative.rds"
pyov_nodes_path  <- "data/interim/nodes_pyoverdines_conservative.rds"

require_file(fg_nodes_path)
require_file(strain_nodes_path)
require_file(pyov_nodes_path)

fg_nodes     <- readRDS(fg_nodes_path)
strain_nodes <- readRDS(strain_nodes_path)
pyov_nodes   <- readRDS(pyov_nodes_path)

# Ensure output directories exist
dir.create("data/interim", recursive = TRUE, showWarnings = FALSE)
dir.create("docs/phase_03", recursive = TRUE, showWarnings = FALSE)

# Basic sanity checks
if (!("agent_id" %in% colnames(fg_nodes))) stop("fg_nodes missing column: agent_id")
if (!("agent_id" %in% colnames(strain_nodes))) stop("strain_nodes missing column: agent_id")
if (!("original_pyov_id" %in% colnames(pyov_nodes) && "matrix_index" %in% colnames(pyov_nodes))) {
  stop("pyov_nodes must include original_pyov_id and matrix_index")
}

# Build mapping: original pyov id -> matrix_index and node_id label
pyov_map <- pyov_nodes %>%
  arrange(matrix_index) %>%
  mutate(original_pyov_id = as.integer(original_pyov_id)) %>%
  select(original_pyov_id, matrix_index, node_id)

pyov_index_by_id <- setNames(pyov_map$matrix_index, pyov_map$original_pyov_id)
n_pyovs <- nrow(pyov_map)

message("Pyov mapping: ", n_pyovs, " pyovs (matrix_index 1..", n_pyovs, ")")

# Helper: map original id vector to matrix indices (drops NAs)
map_pyov_ids_to_indices <- function(ids) {
  ids_int <- as.integer(ids)
  # filter out NA/zero length
  ids_int <- ids_int[!is.na(ids_int)]
  if (length(ids_int) == 0) integer(0) else {
    idx <- pyov_index_by_id[as.character(ids_int)]
    idx <- as.integer(idx[!is.na(idx)])
    unique(idx)
  }
}

# ---------- Build FG-level adjacency matrices ----------
message("Building functional-group-level adjacencies...")

# FG ordering: stable order as present in fg_nodes (assume each row is one FG)
fg_nodes_ordered <- fg_nodes %>% arrange(agent_id)  # stable canonical order
fg_agent_ids <- fg_nodes_ordered$agent_id
n_fg <- length(fg_agent_ids)
message("FG agents (n): ", n_fg)

# Prepare production adjacency (FG x Pyov)
prod_i <- integer(0)
prod_j <- integer(0)

for (r in seq_len(n_fg)) {
  row <- fg_nodes_ordered[r, ]
  # validated_production_set expected to be a list-column of integer vectors of original pyov ids
  prod_set <- row$validated_production_set[[1]]
  if (is.null(prod_set)) next
  pyov_indices <- map_pyov_ids_to_indices(prod_set)
  if (length(pyov_indices) > 0) {
    prod_i <- c(prod_i, rep(r, length(pyov_indices)))
    prod_j <- c(prod_j, pyov_indices)
  }
}

# Create sparse matrix FG(rows) x Pyov(cols)
if (length(prod_i) == 0) {
  adj_prod_fg <- sparseMatrix(i = integer(0), j = integer(0), x = numeric(0),
                              dims = c(n_fg, n_pyovs))
} else {
  adj_prod_fg <- sparseMatrix(i = prod_i, j = prod_j, x = rep(1L, length(prod_i)),
                              dims = c(n_fg, n_pyovs), giveCsparse = TRUE)
}
rownames(adj_prod_fg) <- fg_agent_ids
colnames(adj_prod_fg) <- pyov_map$node_id

# Utilization adjacency (Pyov rows x FG cols)
util_i <- integer(0)  # row: pyov index
util_j <- integer(0)  # col: FG index
for (c in seq_len(n_fg)) {
  row <- fg_nodes_ordered[c, ]
  usable_set <- row$usable_pyoverdine_set[[1]]
  if (is.null(usable_set)) next
  pyov_indices <- map_pyov_ids_to_indices(usable_set)
  if (length(pyov_indices) > 0) {
    util_i <- c(util_i, pyov_indices)
    util_j <- c(util_j, rep(c, length(pyov_indices)))
  }
}

if (length(util_i) == 0) {
  adj_util_fg <- sparseMatrix(i = integer(0), j = integer(0), x = numeric(0),
                              dims = c(n_pyovs, n_fg))
} else {
  adj_util_fg <- sparseMatrix(i = util_i, j = util_j, x = rep(1L, length(util_i)),
                              dims = c(n_pyovs, n_fg), giveCsparse = TRUE)
}
rownames(adj_util_fg) <- pyov_map$node_id
colnames(adj_util_fg) <- fg_agent_ids

# Save FG-level matrices
adj_prod_fg_path <- "data/interim/adj_production_FG_agentsxpyov_conservative.rds"
adj_util_fg_path <- "data/interim/adj_utilization_FG_pyovxagents_conservative.rds"

saveRDS(adj_prod_fg, adj_prod_fg_path)
saveRDS(adj_util_fg, adj_util_fg_path)
message("Saved FG-level adjacencies to ", adj_prod_fg_path, " and ", adj_util_fg_path)

# ---------- Build FG-level edge list (binary) ----------
message("Creating FG-level edge lists...")

# Production edges: for each non-zero in adj_prod_fg, source = agent_id, target = pyov node_id
prod_fg_mat <- summary(adj_prod_fg)  # i, j, x
if (nrow(prod_fg_mat) > 0) {
  edges_prod_fg <- tibble::tibble(
    source = fg_agent_ids[prod_fg_mat$i],
    target = pyov_map$node_id[prod_fg_mat$j],
    source_type = "functional_group",
    target_type = "pyoverdine",
    edge_type = "production"
  )
} else {
  edges_prod_fg <- tibble::tibble(source = character(0), target = character(0),
                                  source_type = character(0), target_type = character(0),
                                  edge_type = character(0))
}

# Utilization edges: pyov -> FG
util_fg_mat <- summary(adj_util_fg)
if (nrow(util_fg_mat) > 0) {
  edges_util_fg <- tibble::tibble(
    source = pyov_map$node_id[util_fg_mat$i],
    target = fg_agent_ids[util_fg_mat$j],
    source_type = "pyoverdine",
    target_type = "functional_group",
    edge_type = "utilization"
  )
} else {
  edges_util_fg <- tibble::tibble(source = character(0), target = character(0),
                                  source_type = character(0), target_type = character(0),
                                  edge_type = character(0))
}

edges_fg <- bind_rows(edges_prod_fg, edges_util_fg) %>%
  distinct()  # deduplicate in case

# Save FG edge lists
edges_fg_rds <- "data/interim/edges_functional_groups_conservative.rds"
edges_fg_csv <- "data/interim/edges_functional_groups_conservative.csv"
saveRDS(edges_fg, edges_fg_rds)
write_csv(edges_fg, edges_fg_csv)
message("Saved FG-level edge lists to ", edges_fg_rds, " and ", edges_fg_csv)

# ---------- Build STRAIN-level adjacency matrices ----------
message("Building strain-level adjacencies...")

# Use stable ordering in strain_nodes
strain_nodes_ordered <- strain_nodes %>% arrange(agent_id)
str_agent_ids <- strain_nodes_ordered$agent_id
n_str <- length(str_agent_ids)
message("Strain agents (n): ", n_str)

# Production adjacency (strain x pyov)
prod_i_str <- integer(0)
prod_j_str <- integer(0)
for (r in seq_len(n_str)) {
  row <- strain_nodes_ordered[r, ]
  prod_set <- row$validated_production_set[[1]]
  if (is.null(prod_set)) next
  pyov_indices <- map_pyov_ids_to_indices(prod_set)
  if (length(pyov_indices) > 0) {
    prod_i_str <- c(prod_i_str, rep(r, length(pyov_indices)))
    prod_j_str <- c(prod_j_str, pyov_indices)
  }
}

if (length(prod_i_str) == 0) {
  adj_prod_str <- sparseMatrix(i = integer(0), j = integer(0), x = numeric(0),
                               dims = c(n_str, n_pyovs))
} else {
  adj_prod_str <- sparseMatrix(i = prod_i_str, j = prod_j_str, x = rep(1L, length(prod_i_str)),
                               dims = c(n_str, n_pyovs), giveCsparse = TRUE)
}
rownames(adj_prod_str) <- str_agent_ids
colnames(adj_prod_str) <- pyov_map$node_id

# Utilization adjacency (pyov x strain)
util_i_str <- integer(0)
util_j_str <- integer(0)
for (c in seq_len(n_str)) {
  row <- strain_nodes_ordered[c, ]
  usable_set <- row$usable_pyoverdine_set[[1]]
  if (is.null(usable_set)) next
  pyov_indices <- map_pyov_ids_to_indices(usable_set)
  if (length(pyov_indices) > 0) {
    util_i_str <- c(util_i_str, pyov_indices)
    util_j_str <- c(util_j_str, rep(c, length(pyov_indices)))
  }
}

if (length(util_i_str) == 0) {
  adj_util_str <- sparseMatrix(i = integer(0), j = integer(0), x = numeric(0),
                               dims = c(n_pyovs, n_str))
} else {
  adj_util_str <- sparseMatrix(i = util_i_str, j = util_j_str, x = rep(1L, length(util_i_str)),
                               dims = c(n_pyovs, n_str), giveCsparse = TRUE)
}
rownames(adj_util_str) <- pyov_map$node_id
colnames(adj_util_str) <- str_agent_ids

# Save strain-level matrices
adj_prod_str_path <- "data/interim/adj_production_STR_agentsxpyov_conservative.rds"
adj_util_str_path <- "data/interim/adj_utilization_STR_pyovxagents_conservative.rds"
saveRDS(adj_prod_str, adj_prod_str_path)
saveRDS(adj_util_str, adj_util_str_path)
message("Saved strain-level adjacencies to ", adj_prod_str_path, " and ", adj_util_str_path)

# ---------- Build STR edge lists ----------
prod_str_mat <- summary(adj_prod_str)
if (nrow(prod_str_mat) > 0) {
  edges_prod_str <- tibble::tibble(
    source = str_agent_ids[prod_str_mat$i],
    target = pyov_map$node_id[prod_str_mat$j],
    source_type = "strain",
    target_type = "pyoverdine",
    edge_type = "production"
  )
} else {
  edges_prod_str <- tibble::tibble(source = character(0), target = character(0),
                                   source_type = character(0), target_type = character(0),
                                   edge_type = character(0))
}

util_str_mat <- summary(adj_util_str)
if (nrow(util_str_mat) > 0) {
  edges_util_str <- tibble::tibble(
    source = pyov_map$node_id[util_str_mat$i],
    target = str_agent_ids[util_str_mat$j],
    source_type = "pyoverdine",
    target_type = "strain",
    edge_type = "utilization"
  )
} else {
  edges_util_str <- tibble::tibble(source = character(0), target = character(0),
                                   source_type = character(0), target_type = character(0),
                                   edge_type = character(0))
}

edges_str <- bind_rows(edges_prod_str, edges_util_str) %>% distinct()
# Save
edges_str_rds <- "data/interim/edges_strains_conservative.rds"
edges_str_csv <- "data/interim/edges_strains_conservative.csv"
saveRDS(edges_str, edges_str_rds)
write_csv(edges_str, edges_str_csv)
message("Saved strain-level edge lists to ", edges_str_rds, " and ", edges_str_csv)

# ---------- Validation & Consistency checks ----------
message("Running consistency checks...")

# 1) Adjacency <-> edge counts
prod_fg_edges_count <- nrow(edges_prod_fg)
prod_fg_mat_count <- sum(adj_prod_fg)
util_fg_edges_count <- nrow(edges_util_fg)
util_fg_mat_count <- sum(adj_util_fg)

prod_str_edges_count <- nrow(edges_prod_str)
prod_str_mat_count <- sum(adj_prod_str)
util_str_edges_count <- nrow(edges_util_str)
util_str_mat_count <- sum(adj_util_str)

checks <- tibble::tibble(
  metric = c("prod_fg_edges_count", "prod_fg_mat_count", "util_fg_edges_count", "util_fg_mat_count",
             "prod_str_edges_count", "prod_str_mat_count", "util_str_edges_count", "util_str_mat_count"),
  value = c(prod_fg_edges_count, prod_fg_mat_count, util_fg_edges_count, util_fg_mat_count,
            prod_str_edges_count, prod_str_mat_count, util_str_edges_count, util_str_mat_count)
)
write_csv(checks, "docs/phase_03/adjacency_counts_check.csv")

# 2) Disjoint namespace check (agent ids vs pyov node ids)
agent_ids_all <- c(fg_agent_ids, str_agent_ids)
pyov_node_ids <- pyov_map$node_id
if (any(agent_ids_all %in% pyov_node_ids)) {
  warning("Namespace collision: Some agent IDs overlap pyov node IDs. Check agent_id and pyov node_id naming.")
}

# 3) Inactive pyovs (no production and no utilization across FG-level)
pyov_total_degree_fg <- Matrix::rowSums(adj_util_fg) + Matrix::colSums(adj_prod_fg)
# Note: adj_prod_fg columns correspond to pyovs -> colSums give number of producing FG per pyov
pyov_col_prod_counts <- as.integer(Matrix::colSums(adj_prod_fg))
pyov_row_util_counts <- as.integer(Matrix::rowSums(adj_util_fg))
inactive_pyovs <- pyov_map$original_pyov_id[(pyov_col_prod_counts == 0) & (pyov_row_util_counts == 0)]
write_csv(tibble(original_pyov_id = inactive_pyovs), "docs/phase_03/inactive_pyovs.csv")

# 4) Self-loops (agent produces and can use same pyov)
# For FG-level: an FG that both produces and consumes the same pyov leads to agent->pyov and pyov->agent edges. Not a classical self-loop but biologically noteworthy.
self_examples <- list()
for (i in seq_len(n_fg)) {
  prod_idx <- which(adj_prod_fg[i, ] != 0)
  util_idx <- which(adj_util_fg[, i] != 0)
  if (length(intersect(prod_idx, util_idx)) > 0) {
    self_examples[[length(self_examples) + 1]] <- list(agent = fg_agent_ids[i],
                                                      pyovs = pyov_map$original_pyov_id[intersect(prod_idx, util_idx)])
  }
}
# Save summary of cases
if (length(self_examples) > 0) {
  self_df <- tibble::tibble(
    agent_id = sapply(self_examples, `[[`, "agent"),
    pyov_overlap = sapply(self_examples, function(x) paste0(x$pyovs, collapse = ","))
  )
  write_csv(self_df, "docs/phase_03/self_producer_consumer_examples_fg.csv")
} else {
  write_csv(tibble(info = "none"), "docs/phase_03/self_producer_consumer_examples_fg.csv")
}

# ---------- Connectivity and components ----------
message("Computing weak components on combined FG bipartite graph (undirected)...")

# Build undirected graph combining production and utilization edges for FG-level network
edges_undirected_fg <- edges_fg %>%
  transmute(from = source, to = target) %>%
  distinct()

# create igraph object
g_fg_undirected <- graph_from_data_frame(edges_undirected_fg, directed = FALSE)
comp_fg <- components(g_fg_undirected)
comp_sizes <- sort(comp_fg$csize, decreasing = TRUE)
n_components <- comp_fg$no
giant_prop <- if (length(comp_sizes) > 0) comp_sizes[1] / sum(comp_sizes) else 0

# Save component summary
comp_summary_fg <- tibble::tibble(
  n_components = n_components,
  giant_component_size = if (length(comp_sizes) > 0) comp_sizes[1] else 0,
  giant_component_proportion = giant_prop
)
write_csv(comp_summary_fg, "docs/phase_03/fg_component_summary.csv")

# Strain-level components
message("Computing weak components on combined STR bipartite graph (undirected)...")
edges_undirected_str <- edges_str %>% transmute(from = source, to = target) %>% distinct()
g_str_undirected <- graph_from_data_frame(edges_undirected_str, directed = FALSE)
comp_str <- components(g_str_undirected)
comp_sizes_str <- sort(comp_str$csize, decreasing = TRUE)
n_components_str <- comp_str$no
giant_prop_str <- if (length(comp_sizes_str) > 0) comp_sizes_str[1] / sum(comp_sizes_str) else 0
comp_summary_str <- tibble::tibble(
  n_components = n_components_str,
  giant_component_size = if (length(comp_sizes_str) > 0) comp_sizes_str[1] else 0,
  giant_component_proportion = giant_prop_str
)
write_csv(comp_summary_str, "docs/phase_03/str_component_summary.csv")

# ---------- Degree sequences and summary object ----------
message("Creating degree sequences object and saving...")

degree_sequences <- list(
  fg_network = list(
    fg_production_out = as.integer(Matrix::rowSums(adj_prod_fg)),    # FG -> PYO
    fg_utilization_in = as.integer(Matrix::colSums(adj_util_fg)),    # FG (consumer) <-- PYO  (col sums of util = per-FG in-degree)
    pyo_production_in = as.integer(Matrix::colSums(adj_prod_fg)),    # PYO <- FG (col sums of prod)
    pyo_utilization_out = as.integer(Matrix::rowSums(adj_util_fg))   # PYO -> FG (row sums of util)
  ),
  strain_network = list(
    str_production_out = as.integer(Matrix::rowSums(adj_prod_str)),
    str_utilization_in = as.integer(Matrix::colSums(adj_util_str)),
    pyo_production_in = as.integer(Matrix::colSums(adj_prod_str)),
    pyo_utilization_out = as.integer(Matrix::rowSums(adj_util_str))
  )
)

saveRDS(degree_sequences, "data/interim/degree_sequences_conservative.rds")
message("Saved degree sequences to data/interim/degree_sequences_conservative.rds")

# ---------- Summary report ----------
summary_lines <- c(
  "Phase 03 - Step 3: Network adjacency construction summary",
  paste("Run timestamp:", Sys.time()),
  "",
  sprintf("Functional-group network: %d agents x %d pyovs", n_fg, n_pyovs),
  sprintf("  - production edges (FG->PYO): %d", prod_fg_mat_count),
  sprintf("  - utilization edges (PYO->FG): %d", util_fg_mat_count),
  sprintf("  - total unique FG-level edges: %d", nrow(edges_fg)),
  "",
  sprintf("Strain network: %d strains x %d pyovs", n_str, n_pyovs),
  sprintf("  - production edges (STR->PYO): %d", prod_str_mat_count),
  sprintf("  - utilization edges (PYO->STR): %d", util_str_mat_count),
  sprintf("  - total unique STR-level edges: %d", nrow(edges_str)),
  "",
  sprintf("Pyov statistics: validated pyovs: %d", n_pyovs),
  sprintf("  - inactive pyovs (no prod & no util at FG-level): %d", length(inactive_pyovs)),
  "",
  "Component summaries saved to docs/phase_03/*_component_summary.csv",
  "Validation CSV saved to docs/phase_03/adjacency_counts_check.csv",
  "Inactive pyovs saved to docs/phase_03/inactive_pyovs.csv",
  "Self-producer-consumer examples saved to docs/phase_03/self_producer_consumer_examples_fg.csv",
  ""
)

writeLines(summary_lines, "docs/phase_03/phase_03_network_summary.txt")
message(paste(summary_lines, collapse = "\n"))

# Save session info
writeLines(capture.output(sessionInfo()), "docs/phase_03/session_info_adj_build.txt")

message("Step 3 complete. Files saved under data/interim and docs/phase_03.")
